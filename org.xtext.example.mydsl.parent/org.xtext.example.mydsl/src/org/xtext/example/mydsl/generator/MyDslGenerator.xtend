/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.EventDefinition
import java.util.HashMap
import org.xtext.example.mydsl.myDsl.Value
import org.xtext.example.mydsl.myDsl.ValueCompute
import org.xtext.example.mydsl.myDsl.RuleDefinition
import org.xtext.example.mydsl.myDsl.VarDefinition
import org.xtext.example.mydsl.myDsl.VarRecall
import org.xtext.example.mydsl.myDsl.JudgeDefinition
import java.util.HashSet
import org.xtext.example.mydsl.MyDslGlobalScopeProvider

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {
	
//	全局变量
	var allFunctions = MyDslGlobalScopeProvider.Functions;
	var allTopics = MyDslGlobalScopeProvider.Topics;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		System.out.println("generate");

		
		fsa.generateFile('greetings.txt', '''
            «FOR event : resource.allContents.filter(EventDefinition).toIterable»
                 event «event.name»
                 «FOR rule:event.rule»
                 	«val subFunctions = new HashSet<String>»
                 	«val vars = achieveVarDefinition(rule,new HashMap<String,String>(),subFunctions)»
                 	«FOR String key:vars.keySet»
                 		«key»«vars.get(key)»
                 	«ENDFOR»
                 	«achieveVarCall(rule,vars,subFunctions)»
                 	«FOR String key: vars.keySet»
                 	 	«key»«vars.get(key)»
                 	«ENDFOR»
                 	«FOR ifttt:rule.ifttt»
                 		«FOR judge:ifttt.judge»
                 			if:«achieveIftttJudge(judge,vars,subFunctions)»
                 		«ENDFOR»
                 		then:«allTopics.get(ifttt.topic.name)»
                 		«FOR fun:subFunctions»url:«fun»
             			«ENDFOR»
                 	«ENDFOR»
                 «ENDFOR»
            «ENDFOR»
        ''')
		System.out.println("generateSuccess");
	}

// 会不会存在一个IFTTT调用多个函数的情况
// IFTTT中judge转成字符串
	def achieveIftttJudge(JudgeDefinition judge,HashMap<String,String> varList,HashSet<String> functions){
		val judges = judge.judge;
		val cons = judge.conjunction;
		var expression = achieveValueCompute(judges.get(0).leftvalue,varList,functions) + judges.get(0).expression + achieveValueCompute(judges.get(0).rightValue,varList,functions)
//		判断此时的链接符是 and 还是 or
		for(var i = 1; i < judges.length; i++){
			var tempCon = cons.get(i-1);
			if(tempCon.equals('and')){
				tempCon = '&'
			}else{
				tempCon = '|'
			}
			expression += tempCon
			expression += achieveValueCompute(judges.get(i).leftvalue,varList,functions) + judges.get(i).expression + achieveValueCompute(judges.get(i).rightValue,varList,functions)
		}
		return expression
	}


	def achieveTopic(){
		
	}


	
//	处理ifttt中左右值的相加减
	def achieveValueCompute(ValueCompute value,HashMap<String,String> varList,HashSet<String> functions){
		
		val values = value.value
		var valueCompute = copeWithValueFour(values.get(0),varList,functions)
		val computes = value.compute
		
		for(var i = 1;i < values.length; i++){
			valueCompute += computes.get(i-1)
			valueCompute += copeWithValueFour(values.get(i),varList,functions)
			
		}
		return valueCompute
		
	}
	
//	处理IFTTT中的左右值
	def copeWithValueFour(Value value,HashMap<String,String> varList,HashSet<String> functions){
		var values = ''
		if(value.rightvalue1 !== null){
			values  = value.rightvalue1
		}else if(value.rightvalue2 !== null){
			values = value.rightvalue2
		}else if(value.rightvalue3 !== null){
			values = value.rightvalue3.refName.name
			functions.add(allFunctions.get(values))
		}else if(value.rightvalue4 !== null){
			values = varList.get(value.rightvalue4.name)
		}
		return values
	}
	
//	获取rule中的var的definition
	def achieveVarDefinition(RuleDefinition rule,HashMap<String,String> varList,HashSet<String> functions){
		var varDefinitions = new HashMap<String,String>();
		for(VarDefinition varDefinition: rule.^var){
			varDefinitions.put(varDefinition.name,achieveValueCompute(varDefinition.rightvalue,varList,functions))
		}
		return varDefinitions
	}


// 如果有var的调用的话，更新var中的后面的值
	def achieveVarCall(RuleDefinition rule,HashMap<String,String> varList,HashSet<String> functions){
		for(VarRecall varRecall: rule.varrecall){
			val call = achieveValueCompute(varRecall.value,varList,functions);
			varList.put(varRecall.varname.name,call)
		}
	}
	
	
}



